<?php

namespace UnknowL\Entity;

use pocketmine\entity\Entity;
use pocketmine\entity\EntitySizeInfo;
use pocketmine\entity\Location;
use pocketmine\math\Vector3;
use pocketmine\nbt\tag\CompoundTag;
use pocketmine\network\mcpe\protocol\StartGamePacket;
use pocketmine\network\mcpe\protocol\types\entity\EntityIds;
use pocketmine\player\Player;
use pocketmine\world\Position;
use UnknowL\Player\PolarisPlayer;
use UnknowL\Trait\VectorUtilsTrait;

class ShulkerEntity extends Entity{

    use VectorUtilsTrait;

    /**
     * @var Vector3[]
     */
    private array $recordedPosition = [];

    private Position $spawnPosition;

    private array $forGame = [];

    public function __construct(Location $location, array $usedforgame = [], ?CompoundTag $nbt = null, PolarisPlayer $player = null){
        $owning = $this->getOwningEntity();
        $this->forGame = $usedforgame;
        $this->spawnPosition = $location->asPosition();
        $this->player = !is_null($player) ? $player : ($owning instanceof PolarisPlayer ? $owning : null);
        parent::__construct($location, $nbt);
    }


    protected function getInitialSizeInfo(): EntitySizeInfo
    {
        return new EntitySizeInfo(0.5, 0.5, 0.5);
    }

    public function onCollideWithPlayer(Player $player): void
    {
        if($this->player instanceof PolarisPlayer){
            if($player->getUniqueId()->equals($this->getOwningEntity()?->getUniqueId())) {
                return;
            }
            $pos = $this->getPosition()->asVector3();
            if(isset($this->forGame["game"])){
                foreach ($this->forGame["game"]->players as $players){
                    $properties = $this->player->getPlayerProperties();
                    if ($properties->getProperties("hasTouched")){
                        $player->sendMessage("§l§b[§a".$this->forGame["game"]->getName()."§b] §aA fait un double kill");
                    }else{
                        $properties->setProperties("hasTouched", true);
                    }
                    if(($distance = $this->spawnPosition->asVector3()->distance($pos)) > 30){
                        $players->sendMessage("§l§b[§a".$this->forGame["game"]->getName()."§b] §a".$this->player->getName()."§a à fait un tir de ".$distance." blocks");
                    }
                }
            }
            $this->flagForDespawn();
            $player->kill();
        }
        parent::onCollideWithPlayer($player); // TODO: Change the autogenerated stub
    }

    public function getSpawnPosition(): Position
    {
        return $this->spawnPosition;
    }

    public function onUpdate(int $currentTick): bool
    {
        if($this->forGame){
            if($currentTick % 20 === 0){
                $this->recordedPosition[] = $this->getPosition()->asVector3();
                $count = count($this->recordedPosition);
                if($count > 10){
                    foreach ($this->recordedPosition as $i => $iValue) {
                        if($iValue->round()->equals($this->recordedPosition[$i === 10? $i : $i + 1]->round())){
                            if ($this->player instanceof PolarisPlayer){
                                $this->player->getPlayerProperties()->setProperties("hasTouched", false);
                            }
                            $this->flagForDespawn();
                        }
                    }
                    $this->recordedPosition = array_slice($this->recordedPosition, 1);
                }
            }
        }
        return parent::onUpdate($currentTick);
    }

    public static function getNetworkTypeId(): string
    {
        return EntityIds::SHULKER_BULLET;
    }
}